<?phpnamespace TMCms\Strings;/** * Class Verify */class Verify{    /**     * @param $data     * @return int|mixed     */    public static function email($data)    {        if (function_exists('filter_var')) {            return filter_var($data, FILTER_VALIDATE_EMAIL);        }        return preg_match('/^([\w\!\#$\%\&\'\*\+\-\/\=\?\^\`{\|\}\~]+\.)*[\w\!\#$\%\&\'\*\+\-\/\=\?\^\`{\|\}\~]+@((((([a-z0-9]{1}[a-z0-9\-]{0,62}[a-z0-9]{1})|[a-z])\.)+[a-z]{2,6})|(\d{1,3}\.){3}\d{1,3}(\:\d{1,5})?)$/i', $data);    }    /**     * Check email's server really exists using MX DNS entry     * @param string $email     * @return bool     */    public static function emailCorrectAndDomainExists($email)    {        $exp = "/^(.*)@(.*)$/";        preg_match($exp, $email, $matches);        if (!empty($matches[1]) && (!filter_var($email, FILTER_VALIDATE_EMAIL))) {            return false;        }        return (checkdnsrr(idn_to_ascii($matches[2]), 'MX'));    }    /**     * @param string $ip     * @return bool|string     */    public static function IpDnsBlacklisted($ip)    {        $dns_black_check = [            'bl.spamcop.net',            'list.dsbl.org',            'sbl.spamhaus.org',            'xbl.spamhaus.org'        ];        $rip = implode('.', array_reverse(explode(".", $ip)));        foreach ($dns_black_check as $val) {            if (checkdnsrr($rip . '.' . $val . '.', 'A')) {                return $rip . '.' . $val;            }        }        return false;    }    /**     * @param string $date     * @param string $format     * @return bool     */    public static function date($date, $format = 'Y-n-j')    {        $rule = self::getDateRegexpAndOrder($format);        $regexp = '/' . $rule['regexp'] . '/';        $order = $rule['order'];        $matches = [];        if (!preg_match($regexp, $date, $matches)) {            return false;        }        $year = $month = $day = false;        foreach ($order as $key => $type) {            $key = $key + 1;            if (!isset($matches[$key])) {                return false;            }            switch ($type) {                case 'year':                    $year = $matches[$key];                    if ($year < 0) {                        return false;                    }                    break;                case 'month':                    $month = $matches[$key];                    if ($month < 0 || $month > 12) {                        return false;                    }                    break;                case 'day':                    $day = $matches[$key];                    if ($day < 0 || $day > 31) {                        return false;                    }                    break;                case 'hour':                    $hour = $matches[$key];                    if ($hour < 0 || $hour > 23) {                        return false;                    }                    break;                case 'minute':                    $minute = $matches[$key];                    if ($minute < 0 || $minute > 59) {                        return false;                    }                    break;            }        }        if ($year && $month && $day && !checkdate($month, $day, $year)) {            return false;        }        return true;    }    /**     * @param $format     * @return array     */    public static function getDateRegexpAndOrder($format)    {        $order = [];        $len = strlen($format);        $date_spec = [            'd', 'D', 'j', 'l', 'N', 'S', 'w', 'z',            'W',            'F', 'm', 'M', 'n', 't',            'L', 'o', 'Y', 'y',            'a', 'A', 'B', 'g', 'G', 'h', 'H', 'i', 's', 'u',            'e', 'I', 'O', 'P', 'T', 'Z',            'c', 'r', 'U'        ];        $regexp = '^';        $sep = '';        for ($i = 0; $i < $len; $i++) {            $symb = $format[$i];            if (!in_array($symb, $date_spec)) {                $sep .= $symb;                continue;            }            $regexp_part = false;            switch ($symb) {                // YEAR                case 'Y':                case 'o':                    $regexp_part = '[0-9]{4}';                    $order[] = 'year';                    break;                case 'y':                    $regexp_part = '[0-9]{2}';                    $order[] = 'year';                    break;                // MONTH                case 'm':                    $regexp_part = '[0-9]{2}';                    $order[] = 'month';                    break;                case 'n':                    $regexp_part = '[0-9]{1,2}';                    $order[] = 'month';                    break;                // DAY                case 'd':                    $regexp_part = '[0-9]{2}';                    $order[] = 'day';                    break;                case 'j':                    $regexp_part = '[0-9]{1,2}';                    $order[] = 'day';                    break;                // HOUR                case 'G':                    $regexp_part = '[0-9]{1,2}';                    $order[] = 'hour';                    break;                // MINUTE                case 'i':                    $regexp_part = '[0-9]{1,2}';                    $order[] = 'minute';                    break;                default:                    dump('Date format ' . $symb . ' character not implemented.');                    break;            }            if ($regexp_part) {                $regexp .= preg_quote($sep) . '(' . $regexp_part . ')';                $sep = '';            }        }        $regexp .= '$';        return ['regexp' => $regexp, 'order' => $order];    }    /**     * @param string $time     * @param string $format     * @return bool     */    public static function time($time, $format = 'G:i')    {        $rule = self::getDateRegexpAndOrder($format);        $regexp = '/' . $rule['regexp'] . '/';        $order = $rule['order'];        $matches = [];        if (!preg_match($regexp, $time, $matches)) {            return false;        }        $year = $month = $day = false;        foreach ($order as $key => $type) {            $key = $key + 1;            if (!isset($matches[$key])) {                return false;            }            switch ($type) {                case 'year':                    $year = $matches[$key];                    if ($year < 0) {                        return false;                    }                    break;                case 'month':                    $month = $matches[$key];                    if ($month < 0 || $month > 12) {                        return false;                    }                    break;                case 'day':                    $day = $matches[$key];                    if ($day < 0 || $day > 31) {                        return false;                    }                    break;                case 'hour':                    $hour = $matches[$key];                    if ($hour < 0 || $hour > 23) {                        return false;                    }                    break;                case 'minute':                    $minute = $matches[$key];                    if ($minute < 0 || $minute > 59) {                        return false;                    }                    break;            }        }        if ($year && $month && $day && !checkdate($month, $day, $year)) {            return false;        }        return true;    }    /**     * @param string $domain_name     * @return bool     */    public static function domain($domain_name)    {        $domain_name = str_replace(['http', 'https', ':', '/'], '', $domain_name); // Remove http:// and trailing slash        return (preg_match("/^([a-z\d](-*[a-z\d])*)(\.([a-z\d](-*[a-z\d])*))*$/i", $domain_name) // Valid chars check            && preg_match("/^.{3,253}$/", $domain_name) // Overall length check            && preg_match("/^[^\.]{1,63}(\.[^\.]{1,63})*$/", $domain_name)); // Length of each label    }    /**     * Validates if string is IP.     * @param string $ip IP     * @return bool $ip IP or domain name     */    public static function isIpAddress($ip)    {        // Check is IP        if (!filter_var($ip, FILTER_VALIDATE_IP) === false) {            return true;        }        if (self::isIpV4($ip)) {            return true;        }        if (self::isIpV6($ip)) {            return true;        }        return false;    }    /**     * @param string $ip     * @return bool     */    public static function isIpV4($ip)    {        // Real IPv4        if (!filter_var($ip, FILTER_VALIDATE_IP, FILTER_FLAG_IPV4) === false) {            return true;        }        return false;    }    /**     * @param string $ip     * @return bool     */    public static function isIpV6($ip)    {        // Real IPv6        if (!filter_var($ip, FILTER_VALIDATE_IP, FILTER_FLAG_IPV6) === false) {            return true;        }        return false;    }}